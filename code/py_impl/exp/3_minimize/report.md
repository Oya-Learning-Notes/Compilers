# DFA Minimization

## 算法基础

对于 DFA 的化简，我们需要考虑以下的情况：

- **Unreachable States:** 不可到达的状态。
- **Dead States:** 死状态（无效状态）。
- **Non-distinguishable States:** 不可区分的状态（等价状态）。

### 不可到达的状态 & 无效状态

对于这两个问题，我们可以采取类似的处理思想，**通过迭代的方式** 逐个移除不符合条件的节点。

- **不可到达的状态：** 迭代移除所有 **入度为零** 的节点，直到无法再移除任何一个节点。
- **无效状态：** 迭代移除所有 **不是终态且出度为零** 的节点，直到无法再移除任何一个节点。

上述提供的方法中，对于无效状态的处理实际上**只是一个快速的近似方法，并不具有绝对的正确性**。考虑这样一个例子：

```
a->b:1
a->c:2
c->d:2
d->c:2
```

![An DFA Example](https://github.com/user-attachments/assets/09a27674-0006-443c-8c95-b848a9e016d6)

注意到，如果使用上述的无效节点检查方法，我们将无法正确检测并移除 `C`, `D` 这两个无效节点。

一个更好的办法是，我们先求出原 DFA 的反向 DFA
（反向 DFA 在这里指的是对原 DFA 的所有转移进行取反，如a->b:x 变成 b->a:x），
然后再删除所有在反向 DFA 中是不可到达的节点。（即所有从可接受节点出发，反向转移无法触及的节点）

### 等价状态

对于 DFA 的确定化，总体上，我们采用书中 "创建初始集合，并不断划分" 的方法。

其中最关键的部份，就是**确定对于某一个状态集合，是否需要拆分，如果需要，如何拆分**的问题。对于这一部份，我们采取以下策略：

1. 首先检查，集合中每个节点可接受的转移字符